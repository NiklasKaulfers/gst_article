\documentclass{report}
\usepackage{float}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[ngerman]{babel}
\usepackage{graphicx,wrapfig,lipsum}
\usepackage{geometry}
\usepackage{minted}
\usepackage{xcolor}
\usepackage{tikz}
\usepackage{csquotes}
\usepackage{dirtree}
\usepackage{hyperref}
\usepackage{fancyhdr}
\usepackage{makecell}
\usepackage{listings}
\usepackage{array}
\usepackage[toc,page]{appendix}
\usepackage[backend=biber,style=ieee]{biblatex}
\addbibresource{main.bib}
\geometry{top=2.5cm, bottom=2.5cm, left=2.5cm, right=2.5cm}
\usetikzlibrary{shapes.geometric, arrows}



% -------------------------------------------------------
% Titelseiten-Informationen
% -------------------------------------------------------
\title{Softwaretests in dem Vier-Gewinnt-Projekt der IIb23}

% Art der Arbeit + Studiengang
\newcommand{\arbeitstyp}{Beleg}
% Modul / Lehrveranstaltung + Dozent:innen
\newcommand{\modul}{Modul / Lehrveranstaltung: Grundlagen des Softwaretestens\\
Dozent: Prof.\ Dr.\ Matthias Längrich}
% Hochschule + Fakultät
\newcommand{\hochschule}{
\includegraphics[height=2.5cm]{LOGO_HSZG_SUBLINE_GRANIT.png}\\[5mm]
Hochschule Zittau/Görlitz \\ Fakultät Elektrotechnik und Informatik
}

% Autor
\author{
    Niklas Kaulfers \\[2mm]
    Matrikelnummer: 1064032
}
% Betreuer (für BA-Thesis, sonst leer lassen)
\newcommand{\betreuer}{}

% Datum der Abgabe
\date{Abgabedatum: \today}

% -------------------------------------------------------
% Titelseite neu definieren
% -------------------------------------------------------
\makeatletter
\renewcommand{\maketitle}{
    \begin{titlepage}
        \centering
        {\Large \hochschule\par}
        \vfill

        {\huge \bfseries \@title\par}
        \vspace{1cm}

        {\large \arbeitstyp\par}
        \vspace{0.5cm}

        {\large \modul\par}
        \vspace{0.5cm}

        {\large \betreuer\par}
        \vspace{1.5cm}

        {\Large \@author\par}
        \vspace{2cm}

        {\large \@date\par}

        \vfill
    \end{titlepage}
}
\makeatother


\fancypagestyle{plain}{%
    \fancyhead[C]{%
        \includegraphics[height=1.25cm]{LOGO_HSZG_SUBLINE_GRANIT_ICON_ONLY.png}%
    }
    \renewcommand{\footrulewidth}{0.4pt}
}

\begin{document}
\pagestyle{plain}
\pagenumbering{gobble}

\setlength{\headheight}{47pt}

\maketitle

\tableofcontents

\pagenumbering{arabic}

\fancyfoot[L]{\sffamily Kaulfers}
\fancyfoot[C]{\sffamily Belegarbeit GST}
\fancyfoot[R]{\sffamily\thepage}

\chapter{Einleitung}
{
    Fehler sind in der Softwareentwicklung nahezu nicht zu vermeiden, 
    jedoch können Entwickler versuchen diesen so gut wie möglich vorzubeugen und somit nicht in entsprechende Produktionsumgebungen vordringen zu lassen. 
    Dies tun sie mittels Softwaretests. In dieser Arbeit wird sich mit der Durchführung dieser Tests an einem Projekt auseinandergesetzt.
    Es wird tiefer auf spezielle Testfälle eingegangen und allgemeine Testvorgehensweisen werden angewandt.\\
    Im Verlauf der Arbeit sind \underline{unterstrichene} und \textit{kursive} Textabschnitte zu finden. 
    \underline{Unterstrichene} sind Links und \textit{kursive} Terminalanweisungen. 
    Teile des Quellcodes, welcher in der Ausarbeitung dieser Arbeit entstand ist hingegen im Anhang\ \ref{chp:Code} zu finden.
\par}

\chapter{Testobjekt}
\section{Vorstellung des Projektes}
    Das Projekt, an welchem die Tests durchgeführt wurden ist ein Gemeinschaftsprojekt des Matrikels IIb23 aus dem Modul OOP (Objektorientierte Programmierung). 
    Es handelt sich hierbei um eine Java-Implementation des Spiels Vier Gewinnt, einem bekannten und relativ leicht verständlichem Strategiespiel. 
    Dieses Spiel zu zweit Spielen spielbar. 
    Das Ziel ist es jeweils 4 der eigenen Steine in einer Reihe zu platzieren und mit eigenen Steinen verhindern, dass der Gegner dasselbe tut.\\
    Die Studenten des Moduls wurden im Rahmen des Moduls in verschiedene Teams aufgeteilt um das Projekt gemeinsam anzufertigen.
    Die Teams waren Projektmanagement, Backend, Frontend und Testing (Ich war Teil des Projektmanagementteams).
    Zur Erstellung wurde über \href{https://github.com/NiklasKaulfers/VierGewinnt}{\underline{GitHub}} kollaboriert.
    Alle im Rahmen dieser Arbeit erbrachten Leistungen sind in dieser GitHub-Repository zu finden.
    Im Fall des Projektes gibt es Möglichkeiten, zum lokalen spielen gegen einen anderen Spieler oder gegen einen Computergegner. 
    Das Spiel hat zudem ein GUI (Graphical User Interface), 
    welches den Spielstand visualisiert und entsprechende Aktionen für den Spieler erlaubt\footnote{\ref{img:gameInProgress}, Screenshot aus dem Spiel}.\\
    Im Hintergrund besteht das Spiel aus 4 Komponenten; Api, Logik, Frontend und Tests.
    Diese sind voneinander logisch in der Ordnerstruktur abgetrennt\footnote{\ref{gph:startProjectLayout}, Layout des Projektes zu Beginn der Tests}.
    Der api Ordern beinhaltet Interfaces, welche die Logik definieren. 
    Hier gibt es auch ein Interface, welches ausschließlich zum Testen gemacht wurde. 
    Die Logik implementiert diese Interfaces und versorgt sie mit Funktionalität.
    Für ein ordentliches grafisches Display sorgt das Frontend. 
    Dieses ist im Vergleich zur Logik deutlich besser modularisiert und somit auch besser lesbar.
    Schlussendlich gibt es in dem Projekt bereits Tests, welche im Test-Ordner sind.
    Jedoch waren diese vor dieser Arbeit noch nicht ausgereift.
 
\subsection{Psychologische Betrachtung}
    Tests werden häufig als unnötig und als Methode zum zeigen, dass es keine Errors gibt angesehen.
    Tatsächlich werden Tests jedoch verwendet um Errors zu finden und fehlverhalten der Software im Vorhinein zu verringern\footfullcite[p.10]{myers2004art}.
    Auch hier im Projekt waren die bereits existieren Tests eher minimal und testen vor allem die Hauptszenarios. 
    Vor allem explizite Logik ist noch ungetestet.\\
    Implementation von Verbesserungen oder eventuelle Bugfixes sind zudem unerwartet, da es sich hierbei um ein abgeschlossenes Projekt handelt.
    Das Projekt hat keinerlei Bugreportmethoden oder ähnliches. Es gibt zwar Issues in der GitHub-Repository, diese werden jedoch nicht in Pullrequests thematisiert.
\subsection{Ökonomische Betrachtung}
    Während im ökonomischen Sinn meist die Gesamtkosten betrachtet werden, ist in dieser Arbeit die Zeit von größerer Bedeutung.
    Rahmen des Projektes stellt das Wintersemester 2025/26.\\
    Die Tests müssen deswegen in einem sehr geringem Zeitrahmen gefertigt werden.\\
    Das Projekt war ein Teil eines Hochschulmoduls, somit waren die Ressourcen stark begrenzt. 
    Auch hierzu anzumerken ist, dass es sich um ein Modul aus dem zweiten Semester handelt, 
    weswegen auch die Erfahrungen der beteiligten noch nicht ausgereift waren.
\section{Nötige Anpassungen}\label{chp:NecessaryChanges}
    Das Projekt auszuführen stellte sich als unnötig komplex heraus, 
    da das Mainfile, welches die Software startet, in einem von vielen Unterordnern aufzufinden war.\\
    Im vor hinein war das Projekt sehr unübersichtlich und benötigte einige Verbesserungen, vor allem in Hinblick auf Namensgebung von Variablen.
    Diese waren Teils mit einzelnen Buchstaben benannt und somit schwer verständlich und lesbar\footnote{\ref{gph:startProjectLayout}, Layout des Projektes zu Beginn der Tests}.\\
    Hier ist eine bessere Projektstruktur, welche eine einfachere Ausführung und Verarbeitung ermöglicht benötigt.
    Um dies zu verwirklichen wurde das Projekt in einer neuen Branch in \href{https://github.com/NiklasKaulfers/VierGewinnt/tree/gradle-test}{\underline{gradle}} neu aufgesetzt.
    Nun kann das Projekt einfach über \textit{gradle run} ausgeführt werden.
    Auch sämtliche Tests sind mit \textit{gradle test} somit leichter zugänglich.\\
    Alle diese Anpassungen geschahen vor einer Umsetzung der Tests um die Entwicklungsumgebung angenehmer zu gestalten.
\section{Eignung zum Testen}
    Da das Projekt aus mehreren verschieden komplexen Codeteilen besteht ist es auch gut zum Testen geeignet. 
    Auch von nutzen hier ist, dass es ein eigenes UI gibt, an welchem auch Tests durchgeführt werden können.\\
    Problematisch hingegen ist, dass das Projekt nicht weiter in Bearbeitung ist und die Tests langfristig eher von geringem Nutzen sein werden.
    Da diese Arbeit als Teil eines Hochschulmoduls zum Lernen angefertigt wurde, ist das im Hinblick auf die Fähigkeit dieses Projekt zu Testen jedoch irrelevant.
    Einen positiven langfristigen Einfluss kann hingegen für Studenten existieren, welche zu alten Projekten zurückkehren und ihre Kompetenzen testen wollen.



\chapter{Planung}
\section{Testziele}
    Um die Tests erfolgreich abzuschließen müssen zuerst die Ziele definiert werden. 
    Hier werden diese vor allem von der Grundsicherung der Funktionalität beeinträchtigt.
    Das Ziel der Tests in diesem Produkt ist es eine hohe Testcoverage zu haben und auch jeweilige Edgecases abzudecken.
    Somit soll das Abstürzen des Spieles auf ein Minimum reduziert werden\footfullcite[vgl.][K. 1 S. 12]{expleo}.\\
    Um eine hohe Qualität der Tests sicherzustellen sollten gewisse Elemente und die damit verbundenen Anforderungen vor der tatsächlichen Umsetzung der Tests aufgelistet werden\footfullcite[vgl.][S. 93]{baresi2006introduction}.
    Eine solche Qualitätsplanung ist auch hier von Sinn\footnote{\ref{gph:testQualityPlan}, Qualitätsplanung für Board}.
    Diese Planung ist nur für Board vorgenommen wurden um in einem sinngemäßen Rahmen zu bleiben.  
\section{Qualitätssicherung}
    Um gute Qualität im Endprodukt zu erhalten muss eine Qualitätssicherung durchgeführt werden. 
    Diese bezieht sich auf den Entwicklungs- als auch den Testprozess und liegt in der Verantwortung aller Projektbeteiligten\footfullcite[K. 1 S. 23]{expleo}.
    Im Verlauf des Projektes wurde der Qualitätssicherungsprozess vollständig ignoriert.
    Daraus kann auch die inkonsistente Codequalität herausgeleitet werden.
    So sind Kommentare in sowohl deutsch als auch englisch und einige Codeabschnitte sind deutlich besser lesbar als andere.
    Somit ist das Projekt langfristig schwer aufrecht zu erhalten und zu erweitern. 
    Da vor dieser Arbeit nur ein geringes Mass an Testen existierte sind auch viele Fehler unbehoben und in der Entwicklung ignoriert wurden.


\chapter{Durchführung}
    Zur Durchführung wird jeweils individuell ein Testfall detailliert erläutert.
\section{Realisierung}
    Als Problem stellt sich direkt heraus, dass Testen nicht isoliert durchgeführt werden soll\footfullcite[K. 1 S. 52]{expleo}.
    Dies ist hier nicht möglich, da keine tatsächliche Entwicklung mehr stattfindet.\\
    Aufgrund der relativ niedrigen Komplexität ist das Einrichten der Entwicklungs-/Testumgebung verhältnismäßig einfach.
    Anforderungen des Projektes sind lediglich Java 21 oder höher.
    Empfohlen wird die IDE IntelliJ IDEA. 
    Um in der Branch mit gradle zu arbeiten muss auch gradle cli installiert sein.
    Die Tests werden mit JUnit 5 durchgeführt und können mittels IntelliJ einfach im Code gestartet werden.
    In der Branch mit gradle ist es einfach, wie in\ \ref{chp:NecessaryChanges}, mit \textit{gradle test} auszuführen.
\section{dynamische Tests}
    Die dynamischen Softwaretests sind in drei Abschnitte zu unterteilen.
    Unit tests stellen die Funktionalität eines Moduls sicher und testen nur dieses.
    Mehrere Module werden im Laufe der Softwareentwicklung aneinandergereiht und verknüpft,
    um dieses Konstrukt zu Testen werden Integration Tests verwendet.
    Der finale Schritt, die System Tests, Testen die gesamte Software aus allen Perspektiven\footfullcite[vgl. ][S. 177]{jamil2016international}.
\subsection{Unit Tests - Verbleibende Plätze in einer Spalte}
    Um zu schauen, ob weiteres platzieren von Steinen in einer Spalte erlaubt ist gibt es eine Funktion \texttt{int isTopOfColumn(int column)}.
    Diese überprüft, wie viele Plätze noch in einer Spalte frei sind.\\
    Wenn man diese Funktion betrachtet fällt zuerst der Name auf. 
    Mit \texttt{isTopOfColumn} ist ein boolean-Wert als Ausgabe zu erwarten.
    Jedoch ist der tatsächliche Rückgabewert vom Typen int.\\
    Zur Implementierung der Tests müssen zuerst Grenzwerte gesetzt werden, in welchen sich die Funktion wie verhalten soll.
    Das Standartboard hat ein Layout von 7x7 somit kommt Abbildung\ \ref{gph:validInputIsTopOfColumn} für die validen inputs der Funktion zustande.
    Daraus folgt, dass Tests für die Inputs -1, 0, 6, 7 durchgeführt werden müssen.
    Die Funktion ist nicht nur von der tatsächlichen Spalte abhängig, sondern auch von der Anzahl der platzierten Steine.
    Somit wird auch getestet, ob die richtigen Werte innerhalb des gültigen Bereichs zurückgegeben werden.
    Um hier das genaue Verhalten zu testen fehlt im Code eine Möglichkeit, um Steine über oder unter dem Spielfeld zu platzieren.
    \begin{figure}[h!]
    \centering
        \begin{tikzpicture}[>=stealth, thick]

            \draw[->] (-3,0) -- (9.5,0) node[right]{Spalte};

            \draw[ultra thick] (0,0.2) -- (0,-0.2) node[above] at (0,0.1) {Untergrenze};
            \draw[ultra thick] (6,0.2) -- (6,-0.2) node[above] at (6,0.1) {Obergrenze};
            
            \foreach \x in {-3,-2,-1,0,1,2,3,4,5,6,7,8,9} {
                \draw (\x,0.15) -- (\x,-0.15) node[below]{\x};
            }

            \draw[very thick, green!60!black] (0,0) -- (6,0);

            \node[above] at (3,0.1) {Gültiger Bereich};

        \end{tikzpicture}
        \caption{Grenzwerte der Inputs von \texttt{isTopOfColumn()} (im Fall des Boardlayouts 7x7)}\label{gph:validInputIsTopOfColumn}
    \end{figure}\\
    In der Durchführung der Tests stellt sich heraus, dass das Verhalten unterhalb der Untergrenze und überhalb der Obergrenze nicht definiert ist.
    Somit kommt es zu einer \texttt{ArrayIndexOutOfBoundsException} für beide Fälle.
    Da es keine Möglichkeit gibt, die Steine so zu platzieren, dass in einer Spalte mehr Steine liegen als vorgesehen, ist es auch nicht möglich das Verhalten in diesem Fall zu testen.
    Für alle anderen Fälle verhält sich die Funktion wie vorgesehen\footnote{siehe Code\ \ref{code:IsTopOfColumnTest}}.

    
\subsection{Integration Tests - Laden und speichern des Spielstands}
    Das Spiel hat eine Speicherlogik. 
    Für diese wird ein String erstellt, welcher den aktuellen Stand des Spieles aufzeichnet.
    Dieser funktioniert wie folgt:\verb!{playerTurn}a{rows}a{columns}a{isFull}aB{boardLayout}!.
    Dieser String wird dann in einem txt-File gespeichert und kann beim neustarten des Spiels aufgerufen werden.
    Für den Test ist es wichtig, dass sich das txt-File ordentlich öffnet und ausliest.
    Zudem muss getestet werden, ob der Speichercode den Spielstand ordnungsgemäß darstellt.
    Auch ist das Verhalten interessant, für den Fall das kein Speicherstand existiert und versucht wird einen zu laden.\\
    Um dem Ziel von Integration Tests zu folgen sind zwischenwerte und interne Abläufe hier unwichtig.
    Von Relevanz is lediglich das richtige Ergebnis, in diesem Fall das richtige Speichern und Auslesen.\\
    Für den Testablauf muss hier nach jedem Durchlauf der Zustand der Dateien wieder zum ausgangszustand zurückgebracht werden.
    Da das Speichern des Spiels eine Datei erstellt, welche zuvor noch nicht da ist.\\
    Das Diagram\ \ref{gph:IntegrationTest} zeigt auf, wie der Speicher- \& Ladeprozess im Spiel funktioniert.
    \begin{figure}[ht!]
        \centering
        \tikzstyle{block} = [
            rectangle, rounded corners,
            minimum width=3.5cm, minimum height=1.2cm,
            text centered, draw=black,
            text width=3cm
        ]
        \tikzstyle{decision} = [
            diamond, aspect=2,
            text centered, draw=black
        ]
        \tikzstyle{startstop} = [
            ellipse,
            minimum width=4cm, minimum height=1.2cm,
            text centered, draw=black
        ]
        \tikzstyle{arrow} = [
            thick, ->, >=stealth
        ]
    
        \begin{tikzpicture}[node distance=2.5cm]

            \node (start)        [startstop] {Initialisierung eines neuen Boards};
    
            \node (loadLayout)   [block, below of=start] {Laden des Spielfelds};
    
            \node (decisionUser) [decision, below of=loadLayout, yshift=-0.5cm]{Zustandsänderung?};
    
            \node (pressSave)    [block, right of=decisionUser, xshift=3.0cm]{Speicherknopf};
    
            \node (play)         [block, below of=decisionUser]{Aktionen auf dem Spielfeld\\Updaten des Boards};
    
            \node (loadGame)     [block, left of=decisionUser, xshift=-3.0cm]{Ladenknopf};
    
            \node (createSave)   [block, below of=pressSave] {Erstellen der Speicherdatei};
    
            \node (accessSave)   [block, below of=loadGame]{Laden der Speicherdatei\\Updaten des Boards};
    
            % Arrows
            \draw[arrow] (start) -- (loadLayout);
            \draw[arrow] (loadLayout) -- (decisionUser);
    
            \draw[arrow] (decisionUser) -- (pressSave);
            \draw[arrow] (pressSave) -- (createSave);
            \draw[arrow] (createSave) -- (decisionUser);
    
            \draw[arrow] (decisionUser) -- (play);
            \draw[arrow] (play) -- (decisionUser);
    
            \draw[arrow] (decisionUser) -- (loadGame);
            \draw[arrow] (loadGame) -- (accessSave);
            \draw[arrow] (accessSave) -- (decisionUser);
    
        \end{tikzpicture}
    
        \caption{Flowchart für Speicher-/Ladeprozess}\label{gph:IntegrationTest}
    \end{figure}\\
    Aus der Figur\ \ref{gph:IntegrationTest} ist bereits ein Problem des Speicherkonzepts zu erkennen, die Datei wird erst mit erstmaligem Speicher erstellt.
    Der Knopf zum Laden des Spiels hingegen ist bereits mit dem Öffnen des Spiels möglich.
    Dies kann zu Fehlern und undefinierten Verhalten führen.\\
    In der tatsächlichen Durchführung der Tests bewahrheitet sich dies.
    Der \texttt{FileReader} findet keine Datei zum auslesen und wirft ein Error. 

    

\subsection{System Testing}

\section{statische Tests}

\chapter{Probleme des Projektes}
\section{Behobene Probleme}
\section{Nicht behobene Probleme}

\chapter{Fazit}

\begin{appendices}
\chapter{Grafiken}
    \begin{figure}
        \caption{Bild des Spiels}\label{img:gameInProgress}
        \includegraphics[width=\linewidth]{screenshot_game_inprogress.png}
    \end{figure}
    \newpage
    \begin{figure}
        \caption{Projektstruktur vor Verbesserungen (Einstiegspunkt in rot)}\label{gph:startProjectLayout}
        \dirtree{%
        .1 VierGewinnt/.
        .2 lib/.
        .3 junit-platform-console-standalone.jar.
        .2 res/.
        .3 SpielerVsComputer.png.
        .3 SpielerVsSpieler.png.
        .2 src/.
        .3 api/.
        .4 BoardInterface.java.
        .4 BoardTestInterface.java.
        .4 TileInterface.java.
        .3 gui/.
        .4 entity/.
        .5 BordersForCircle.java.
        .5 Circle.java.
        .4 frames/.
        .5 EndFrame.java.
        .5 MainPanel.java.
        .5 OptionsFrame.java.
        .5 StartFrame.java.
        .4 handler/.
        .5 MouseHandler.java.
        .4 main/.
        .5 \textcolor{red}{App.java}.
        .3 logic/.
        .4 Board.java.
        .4 Tile.java.
        .3 test/.
        .4 GameTest.java.
        .2 {.gitignore}.
        .2 README.md.
        .2 TEST.md.
        .2 VierGewinnt.jar.
        .2 win4.jar.
        }
    \end{figure}
    \newpage
\chapter{Tabellen}
    \begin{figure}
        \caption{Planung der Tests für Board.java (nach \fullcite[S. 93f.]{baresi2006introduction})}\label{gph:testQualityPlan}
        \begin{center}
            \begin{tabular}{ | c | c | }
                \hline
                Test Items & Board.java \\
                \hline
                Features to be tested & placeStone, computer algorithm, save/load, winning \\
                \hline
                Features not to be tested & Setters/Getters \\
                \hline
                Approach & \makecell{Unit Tests mit Grenzwerten oder\\
                    Äquivalenzklassen für zu umfangreichen Code\\
                    Integration Tests für einen Spielablauf mit Use Case\\
                    KI-basiertes Testen für höhere Effizienz bei redundanten Fällen}\\
                \hline
                Pass/Fail criteria & \makecell{Alle Funktionen verhalten sich wie erwartet\\
                    Fail bei unter 100\% Success}\\
                \hline 
                Suspension and resumption criteria & 
                    \makecell{Codequalität zu niedrig bzw unlesbar:\\
                    Codeverbesserungen sind umgesetzt\\ \\
                    Kritischer Error/Crash:\\
                    Fix des kritischen Errors}
                    \\
                \hline
                Risks and contingencies & Zeitliche Begrenzungen \\
                \hline
                Deliverables & Bugs und generelle QA \\
                \hline 
                Tasks \& Schedule & Zeit bis Februar 2025 \\
                \hline 
                Staff \& responsibilities & \makecell{Niklas Kaulfers (Umsetzung),\\IIb23 (Bereitstellung des Projekts und Softwareentwicklung)} \\
                \hline 
                Environment needs & JUnit, Java correto 23, IntelliJ IDEA \\
                \hline
            \end{tabular}
        \end{center}
    \end{figure}
    \newpage
\chapter{Code}\label{chp:Code}
\begin{lstlisting}[language=Java, caption={IsTopOfColumnTest.java}, label={code:IsTopOfColumnTest}]
    package test.logic.board;
    
    import api.BoardTestInterface;
    import logic.Board;
    import org.junit.jupiter.api.Assertions;
    import org.junit.jupiter.api.BeforeEach;
    import org.junit.jupiter.api.DisplayName;
    import org.junit.jupiter.api.Test;
    
    public class IsTopOfColumnTest {
    
        BoardTestInterface board;
    
        @BeforeEach
        void setUp() {
            board = new Board();
        }
    
        @Test
        @DisplayName(
            "WHEN column 1 has 3 stones placed THEN return 3"
        )
        void halfwayFullColumnTest() {
            board.placeStone(1);
            board.placeStone(1);
            board.placeStone(1);
    
            Assertions.assertEquals(
                3,
                board.isTopOfColumn(1)
            );
        }
    
        @Test
        @DisplayName(
            "WHEN column 1 has 6 stones THEN return 0"
        )
        void fullColumnTest() {
            for (int i = 0; i < 6; i++) {
                board.placeStone(1);
            }
    
            Assertions.assertEquals(
                0,
                board.isTopOfColumn(1)
            );
        }
    
        @Test
        @DisplayName(
            "WHEN column 1 has 0 stones THEN return 6"
        )
        void emptyColumnTest() {
            Assertions.assertEquals(
                6,
                board.isTopOfColumn(1)
            );
        }
    
        @Test
        @DisplayName(
            "GIVEN a 10x10 board WHEN column 10 has 0 "
          + "stones THEN return 10"
        )
        void emptyColumn10Test() {
            board = new Board(10, 10);
    
            Assertions.assertEquals(
                10,
                board.isTopOfColumn(9)
            );
        }
    
        @Test
        @DisplayName(
            "GIVEN a 10x10 board WHEN column 1 has 10 "
          + "stones THEN return 0"
        )
        void fullColumn10Test() {
            board = new Board(10, 10);
    
            for (int i = 0; i < 10; i++) {
                board.placeStone(1);
            }
    
            Assertions.assertEquals(
                0,
                board.isTopOfColumn(1)
            );
        }
    
        @Test
        @DisplayName(
            "WHEN column -1 is called THEN do nothing"
        )
        void outOfBoundsTooLowTest() {
            Assertions.assertEquals(
                0,
                board.isTopOfColumn(-1)
            );
        }
    
        @Test
        @DisplayName(
            "WHEN column 7 is called THEN do nothing"
        )
        void outOfBoundsTooHighTest() {
            Assertions.assertEquals(
                0,
                board.isTopOfColumn(7)
            );
        }
    
        @Test
        @DisplayName(
            "WHEN column 0 is called and no stones are "
          + "placed THEN return 6"
        )
        void emptyColumn0Test() {
            Assertions.assertEquals(
                6,
                board.isTopOfColumn(0)
            );
        }
    
        @Test
        @DisplayName(
            "WHEN column 6 is called and no stones are "
          + "placed THEN return 6"
        )
        void emptyColumn6Test() {
            Assertions.assertEquals(
                6,
                board.isTopOfColumn(6)
            );
        }
    }
    \end{lstlisting}
    
    
\end{appendices}
\printbibliography\end{document}