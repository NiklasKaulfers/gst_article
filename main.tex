\documentclass{report}
\usepackage{float}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[ngerman]{babel}
\usepackage{graphicx,wrapfig,lipsum}
\usepackage{geometry}
\usepackage{minted}
\usepackage{xcolor}
\usepackage{tikz}
\usepackage{csquotes}
\usepackage{dirtree}
\usepackage{hyperref}
\usepackage{fancyhdr}
\usepackage{makecell}
\usepackage{listings}
\usepackage{array}
\usepackage[toc,page]{appendix}
\usepackage[backend=biber,style=ieee]{biblatex}
\addbibresource{main.bib}
\geometry{top=2.5cm, bottom=2.5cm, left=2.5cm, right=2.5cm}
\usetikzlibrary{shapes.geometric, arrows}



% -------------------------------------------------------
% Titelseiten-Informationen
% -------------------------------------------------------
\title{Softwaretests in dem Vier-Gewinnt-Projekt der IIb23}

% Art der Arbeit + Studiengang
\newcommand{\arbeitstyp}{Beleg}
% Modul / Lehrveranstaltung + Dozent:innen
\newcommand{\modul}{Modul / Lehrveranstaltung: Grundlagen des Softwaretestens\\
Dozent: Prof.\ Dr.\ Matthias Längrich}
% Hochschule + Fakultät
\newcommand{\hochschule}{
\includegraphics[height=2.5cm]{LOGO_HSZG_SUBLINE_GRANIT.png}\\[5mm]
Hochschule Zittau/Görlitz \\ Fakultät Elektrotechnik und Informatik
}

% Autor
\author{
    Niklas Kaulfers \\[2mm]
    Matrikelnummer: 1064032
}
% Betreuer (für BA-Thesis, sonst leer lassen)
\newcommand{\betreuer}{}

% Datum der Abgabe
\date{Abgabedatum: \today}

% -------------------------------------------------------
% Titelseite neu definieren
% -------------------------------------------------------
\makeatletter
\renewcommand{\maketitle}{
    \begin{titlepage}
        \centering
        {\Large \hochschule\par}
        \vfill

        {\huge \bfseries \@title\par}
        \vspace{1cm}

        {\large \arbeitstyp\par}
        \vspace{0.5cm}

        {\large \modul\par}
        \vspace{0.5cm}

        {\large \betreuer\par}
        \vspace{1.5cm}

        {\Large \@author\par}
        \vspace{2cm}

        {\large \@date\par}

        \vfill
    \end{titlepage}
}
\makeatother


\fancypagestyle{plain}{%
    \fancyhead[C]{%
        \includegraphics[height=1.25cm]{LOGO_HSZG_SUBLINE_GRANIT_ICON_ONLY.png}%
    }
    \renewcommand{\footrulewidth}{0.4pt}
}

\begin{document}
\pagestyle{plain}
\pagenumbering{gobble}

\setlength{\headheight}{47pt}

\maketitle

\tableofcontents

\pagenumbering{arabic}

\fancyfoot[L]{\sffamily Kaulfers}
\fancyfoot[C]{\sffamily Belegarbeit GST}
\fancyfoot[R]{\sffamily\thepage}

\chapter{Einleitung}
{
    Fehler sind in der Softwareentwicklung nahezu nicht zu vermeiden, 
    jedoch können Entwickler versuchen diesen so gut wie möglich vorzubeugen und somit nicht in entsprechende Produktionsumgebungen vordringen zu lassen. 
    Dies tun sie mittels Softwaretests. In dieser Arbeit wird sich mit der Durchführung dieser Tests an einem Projekt auseinandergesetzt.
    Es wird tiefer auf spezielle Testfälle eingegangen und allgemeine Testvorgehensweisen werden angewandt.
    Um die Testfälle genauer zu verstehen wird zuerst eine Analyse des Testobjektes durchgeführt.
    Hieran wird die Komplexität des Projektes ermittelt und eventuelle bereits sichtbare Probleme diskutiert.
    Anschließend werden die entsprechenden Grundlagen des Softwaretestens, welche von Bedeutung in dieser Arbeit sind, vorgestellt und erläutert.
    Daraufhin wird eine Planung des Testablaufs durchgeführt und hierbei an einzelnen Fällen ein tieferer Einblick gegeben.
    Zur Durchführung wird zu jedem der vorgestellten Möglichkeiten des Testens eine an einem Beispiel des Projektes gezeigt.
    Diese sind im direkten Zusammenhang zu Softwareentwicklung innerhalb des Projektes, welche im Rahmen dieser Arbeit erfolgten.
    Schlussendlich werden Probleme des Projektes, welche Mithilfe der Tests aufgespürt wurden aufgezeigt und teils auch behoben.
    Inwiefern diese Arbeit erfolgreich war und mögliche Konsequenzen können aus dem Fazit entnommen werden.\\
    Im Verlauf der Arbeit sind \underline{unterstrichene} und \textit{kursive} Textabschnitte zu finden. 
    \underline{Unterstrichene} sind Links und \textit{kursive} Terminalanweisungen. 
    Teile des Quellcodes, welcher in der Ausarbeitung dieser Arbeit entstand ist hingegen im Anhang\ \ref{chp:Code} zu finden.
\par}

\chapter{Testobjekt}
\section{Vorstellung des Projektes}
    Das Projekt, an welchem die Tests durchgeführt wurden ist ein Gemeinschaftsprojekt des Matrikels IIb23 aus dem Modul OOP (Objektorientierte Programmierung). 
    Es handelt sich hierbei um eine Java-Implementation des Spiels Vier Gewinnt, einem bekannten und relativ leicht verständlichem Strategiespiel. 
    Dieses Spiel zu zweit Spielen spielbar. 
    Das Ziel ist es jeweils 4 der eigenen Steine in einer Reihe zu platzieren und mit eigenen Steinen verhindern, dass der Gegner dasselbe tut.\\
    Die Studenten des Moduls wurden im Rahmen des Moduls in verschiedene Teams aufgeteilt um das Projekt gemeinsam anzufertigen.
    Die Teams waren Projektmanagement, Backend, Frontend und Testing (Ich war Teil des Projektmanagementteams).
    Zur Erstellung wurde über \href{https://github.com/NiklasKaulfers/VierGewinnt}{\underline{GitHub}} kollaboriert.
    Alle im Rahmen dieser Arbeit erbrachten Leistungen sind in dieser GitHub-Repository zu finden.
    Im Fall des Projektes gibt es Möglichkeiten, zum lokalen spielen gegen einen anderen Spieler oder gegen einen Computergegner. 
    Das Spiel hat zudem ein GUI (Graphical User Interface), 
    welches den Spielstand visualisiert und entsprechende Aktionen für den Spieler erlaubt\footnote{\ref{img:gameInProgress}, Screenshot aus dem Spiel}.\\
    Im Hintergrund besteht das Spiel aus 4 Komponenten; Api, Logik, Frontend und Tests.
    Diese sind voneinander logisch in der Ordnerstruktur abgetrennt\footnote{\ref{gph:startProjectLayout}, Layout des Projektes zu Beginn der Tests}.
    Der api Ordern beinhaltet Interfaces, welche die Logik definieren. 
    Hier gibt es auch ein Interface, welches ausschließlich zum Testen gemacht wurde. 
    Die Logik implementiert diese Interfaces und versorgt sie mit Funktionalität.
    Für ein ordentliches grafisches Display sorgt das Frontend. 
    Dieses ist im Vergleich zur Logik deutlich besser modularisiert und somit auch besser lesbar.
    Schlussendlich gibt es in dem Projekt bereits Tests, welche im Test-Ordner sind.
    Jedoch waren diese vor dieser Arbeit noch nicht ausgereift.
 
\subsection{Psychologische Betrachtung}
    Tests werden häufig als unnötig und als Methode zum zeigen, dass es keine Errors gibt angesehen.
    Tatsächlich werden Tests jedoch verwendet um Errors zu finden und fehlverhalten der Software im Vorhinein zu verringern\footfullcite[p.10]{myers2004art}.
    Auch hier im Projekt waren die bereits existieren Tests eher minimal und testen vor allem die Hauptszenarios. 
    Vor allem explizite Logik ist noch ungetestet.\\
    Implementation von Verbesserungen oder eventuelle Bugfixes sind zudem unerwartet, da es sich hierbei um ein abgeschlossenes Projekt handelt.
    Das Projekt hat keinerlei Bugreportmethoden oder ähnliches. 
    Es gibt zwar Issues in der GitHub-Repository, diese werden jedoch nicht in Pullrequests (PR) thematisiert.
    Generell wurden die meisten Features nicht per PR in die Mainbranch gemerged.
    In diesem Projekt können Mitentwickler einfach merges in die Mainbranch durchführen, da diese nicht geschützt ist. 
\subsection{Ökonomische Betrachtung}
    Während im ökonomischen Sinn meist die Gesamtkosten betrachtet werden, ist in dieser Arbeit die Zeit von größerer Bedeutung.
    Rahmen des Projektes stellt das Wintersemester 2025/26.\\
    Die Tests müssen deswegen in einem sehr geringem Zeitrahmen gefertigt werden.\\
    Das Projekt war ein Teil eines Hochschulmoduls, somit waren die Ressourcen stark begrenzt. 
    Auch hierzu anzumerken ist, dass es sich um ein Modul aus dem zweiten Semester handelt, 
    weswegen auch die Erfahrungen der beteiligten noch nicht ausgereift waren.
\section{Nötige Anpassungen}\label{chp:NecessaryChanges}
    Das Projekt auszuführen stellte sich als unnötig komplex heraus, 
    da das Mainfile, welches die Software startet, in einem von vielen Unterordnern aufzufinden war.\\
    Im vor hinein war das Projekt sehr unübersichtlich und benötigte einige Verbesserungen, vor allem in Hinblick auf Namensgebung von Variablen.
    Diese waren Teils mit einzelnen Buchstaben benannt und somit schwer verständlich und lesbar\footnote{\ref{gph:startProjectLayout}, Layout des Projektes zu Beginn der Tests}.\\
    Hier ist eine bessere Projektstruktur, welche eine einfachere Ausführung und Verarbeitung ermöglicht benötigt.
    Um dies zu verwirklichen wurde das Projekt in einer neuen Branch in \href{https://github.com/NiklasKaulfers/VierGewinnt/tree/gradle-test}{\underline{gradle}} neu aufgesetzt.
    Nun kann das Projekt einfach über \textit{gradle run} ausgeführt werden.
    Auch sämtliche Tests sind mit \textit{gradle test} somit leichter zugänglich.\\
    Alle diese Anpassungen geschahen vor einer Umsetzung der Tests um die Entwicklungsumgebung angenehmer zu gestalten.
\section{Eignung zum Testen}
    Da das Projekt aus mehreren verschieden komplexen Codeteilen besteht ist es auch gut zum Testen geeignet. 
    Auch von nutzen hier ist, dass es ein eigenes UI gibt, an welchem auch Tests durchgeführt werden können.\\
    Problematisch hingegen ist, dass das Projekt nicht weiter in Bearbeitung ist und die Tests langfristig eher von geringem Nutzen sein werden.
    Da diese Arbeit als Teil eines Hochschulmoduls zum Lernen angefertigt wurde, ist das im Hinblick auf die Fähigkeit dieses Projekt zu Testen jedoch irrelevant.
    Einen positiven langfristigen Einfluss kann hingegen für Studenten existieren, welche zu alten Projekten zurückkehren und ihre Kompetenzen testen wollen.

\chapter{Grundlagen}
\section{statisch oder dynamisch}
    Statische und dynamische Tests sind in jeder modernen Software angewandt. 
    Jedoch was ist der Unterschied?
    Bei statischen oder manuellen\footfullcite[S. 981]{sawant2012software} Tests wird die Struktur des Codes analysiert, aber der Code nicht ausgeführt\footfullcite[S. 14]{fairley1978static}.
    Im Gegensatz dazu werden dynamische oder automatisierte Tests von einem Testplan abgeleitet, ausgeführt und als Resultat evaluiert\footfullcite[S. 16]{fairley1978static}.
    Somit stellen statische Tests beispielsweise Code Reviews da, während dynamische Tests die Tests der Testsuit in der Codebasis sind.
\section{Vorwissen und Einblick der Tester}
    Es gibt drei Methoden Tests durchzuführen. Diese sind Whitebox- und Blackboxtesting.
    Blackboxtesting wird auch funktionales Testen genannt\footfullcite[S. 1278f.]{basili1987comparing} in diese ´´schwarzen Box´´(nicht durchsichtigen) kann der Tester nicht hineinsehen.
    Somit soll der Tester keinen Zugang zum Code haben und interessiert sich einzig und allein für den richtigen Ausgabewert\footfullcite[S. 29f.]{nidhra2012black}
    Im Gegensatz dazu hat Whiteboxtesting Zugang zum Code für die Tester, um auf die Analogie der ´´schwarze Box´´ zurückzukommen wird Whiteboxtesting auch als Struktur- oder Glasboxtests bezeichnet\footfullcite[S. 30]{nidhra2012black}\footfullcite[S. 1279]{basili1987comparing}
    Teils wird auch Greyboxtesting erwähnt\footfullcite[S. 2]{jamil2016international}.
    Dies ist eine Methode, bei welcher die Tester etwas Vorwissen von der Codebasis haben\footfullcite[S. 2]{jovanovic2006software}
    Sie versucht die Probleme von Blackbox- und Whiteboxtesting zu lösen. 
    So kann beispielsweise Backendlogik über das Frontend getestet werden, die Tester kenne den Code des Backends hierbei, jedoch nicht den des Frontends.
    Diese Form des Testens eignet sich so sehr gut für Webanwendungen\footfullcite[S. 179]{acharya2012bridge}.
\section{Spektrum an Tests}
Um Software zu Testen gibt es eine Vielzahl an verschiedenen Tests, welche an der Software durchgeführt werden können.
Diese Tests werden zu verschiedenen Zeitpunkten im Softwaredevelopmentlifecycle angewandt\footfullcite[S. 30]{nidhra2012black}.
\subsection{Arten der statischen Tests}
Eine typische Form der statischen Tests ist das Codereview.
Bei diesem wird der geschriebene Code von einem anderem Entwickler überprüft.
Moderne Codereviews sind informell, toolbasiert, asynchron und fokussiert auf Codeänderungen\footfullcite[S. 181]{sadowski2018modern}.
Es gibt eine Menge an verschiedenen Arten, wie diese Codereviews durchgeführt werden können.
Dazu zählen die Codeinspektion, asynchrone Reviews per Email, toolbasierte Reviews und pullbasierte Reviews.
Diese pullbasierten Reviews beziehen sich auf Reviews von Pullrequests, beispielsweise über GitHub\footfullcite[vgl. ][S. 182]{sadowski2018modern}.
\subsection{Arten der dynamischen Tests}
   


\chapter{Planung}
\section{Testziele}
    Um die Tests erfolgreich abzuschließen müssen zuerst die Ziele definiert werden. 
    Hier werden diese vor allem von der Grundsicherung der Funktionalität beeinträchtigt.
    Das Ziel der Tests in diesem Produkt ist es eine hohe Testcoverage zu haben und auch jeweilige Edgecases abzudecken.
    Somit soll das Abstürzen des Spieles auf ein Minimum reduziert werden\footfullcite[vgl.][K. 1 S. 12]{expleo}.\\
    Um eine hohe Qualität der Tests sicherzustellen sollten gewisse Elemente und die damit verbundenen Anforderungen vor der tatsächlichen Umsetzung der Tests aufgelistet werden\footfullcite[vgl.][S. 93]{baresi2006introduction}.
    Eine solche Qualitätsplanung ist auch hier von Sinn\footnote{\ref{gph:testQualityPlan}, Qualitätsplanung für Board}.
    Diese Planung ist nur für Board vorgenommen wurden um in einem sinngemäßen Rahmen zu bleiben.  
\section{Qualitätssicherung}
    Um gute Qualität im Endprodukt zu erhalten muss eine Qualitätssicherung durchgeführt werden. 
    Diese bezieht sich auf den Entwicklungs- als auch den Testprozess und liegt in der Verantwortung aller Projektbeteiligten\footfullcite[K. 1 S. 23]{expleo}.
    Im Verlauf des Projektes wurde der Qualitätssicherungsprozess vollständig ignoriert.
    Daraus kann auch die inkonsistente Codequalität herausgeleitet werden.
    So sind Kommentare in sowohl deutsch als auch englisch und einige Codeabschnitte sind deutlich besser lesbar als andere.
    Somit ist das Projekt langfristig schwer aufrecht zu erhalten und zu erweitern. 
    Da vor dieser Arbeit nur ein geringes Mass an Testen existierte sind auch viele Fehler unbehoben und in der Entwicklung ignoriert wurden.


\chapter{Durchführung}
    Zur Durchführung wird jeweils individuell ein Testfall detailliert erläutert.
\section{Realisierung}
    Als Problem stellt sich direkt heraus, dass Testen nicht isoliert durchgeführt werden soll\footfullcite[K. 1 S. 52]{expleo}.
    Dies ist hier nicht möglich, da keine tatsächliche Entwicklung mehr stattfindet.\\
    Aufgrund der relativ niedrigen Komplexität ist das Einrichten der Entwicklungs-/Testumgebung verhältnismäßig einfach.
    Anforderungen des Projektes sind lediglich Java 21 oder höher.
    Empfohlen wird die IDE IntelliJ IDEA.\@
    Um in der Branch mit gradle zu arbeiten muss auch gradle cli installiert sein.
    Die Tests werden mit JUnit 5 durchgeführt und können mittels IntelliJ einfach im Code gestartet werden.
    In der Branch mit gradle ist es einfach, wie in\ \ref{chp:NecessaryChanges}, mit \textit{gradle test} auszuführen.
\section{dynamische Tests}
    Die dynamischen Softwaretests sind in drei Abschnitte zu unterteilen.
    Unit tests stellen die Funktionalität eines Moduls sicher und testen nur dieses.
    Mehrere Module werden im Laufe der Softwareentwicklung aneinandergereiht und verknüpft,
    um dieses Konstrukt zu Testen werden Integration Tests verwendet.
    Der finale Schritt, die System Tests, Testen die gesamte Software aus allen Perspektiven\footfullcite[vgl. ][S. 177]{jamil2016international}.
\subsection{Unit Tests - Verbleibende Plätze in einer Spalte}
    Um zu schauen, ob weiteres platzieren von Steinen in einer Spalte erlaubt ist gibt es eine Funktion \texttt{int isTopOfColumn(int column)}.
    Diese überprüft, wie viele Plätze in einer Spalte noch frei sind.\\
    Wenn man diese Funktion betrachtet fällt zuerst der Name auf. 
    Mit \texttt{isTopOfColumn} ist ein boolean-Wert als Ausgabe zu erwarten.
    Jedoch ist der tatsächliche Rückgabewert vom Typen int.
    Somit wird die Anzahl der Plätze welche bis zur Maximalmenge zur Verfügung stehen gezählt und dementsprechend 0 zurückgegeben, wenn kein Platz frei ist.\\
    Zur Implementierung der Tests müssen zuerst Grenzwerte gesetzt werden, in welchen sich die Funktion wie verhalten soll.
    Das Standartboard hat ein Layout von 7x7 somit kommt Abbildung\ \ref{gph:validInputIsTopOfColumn} für die validen inputs der Funktion zustande.
    Daraus folgt, dass Tests für die Inputs -1, 0, 6, 7 durchgeführt werden müssen.
    Die Funktion ist nicht nur von der tatsächlichen Spalte abhängig, sondern auch von der Anzahl der platzierten Steine.
    Somit wird auch getestet, ob die richtigen Werte innerhalb des gültigen Bereichs zurückgegeben werden.
    Um hier das genaue Verhalten zu testen fehlt im Code eine Möglichkeit, um Steine über oder unter dem Spielfeld zu platzieren.
    \begin{figure}[ht!]
    \centering
        \begin{tikzpicture}[>=stealth, thick]

            \draw[->] (-3,0) -- (9.5,0) node[right]{Spalte};

            \draw[ultra thick] (0,0.2) -- (0,-0.2) node[above] at (0,0.1) {Untergrenze};
            \draw[ultra thick] (6,0.2) -- (6,-0.2) node[above] at (6,0.1) {Obergrenze};
            
            \foreach \x in {-3,-2,-1,0,1,2,3,4,5,6,7,8,9} {
                \draw (\x,0.15) -- (\x,-0.15) node[below]{\x};
            }

            \draw[very thick, green!60!black] (0,0) -- (6,0);

            \node[above] at (3,0.1) {Gültiger Bereich};

        \end{tikzpicture}
        \caption{Grenzwerte der Inputs von \texttt{isTopOfColumn()} (im Fall des Boardlayouts 7x7)}\label{gph:validInputIsTopOfColumn}
    \end{figure}\\
    In der Durchführung der Tests stellt sich heraus, dass das Verhalten unterhalb der Untergrenze und überhalb der Obergrenze nicht definiert ist.
    Somit kommt es zu einer \texttt{ArrayIndexOutOfBoundsException} für beide Fälle.
    Da es keine Möglichkeit gibt, die Steine so zu platzieren, dass in einer Spalte mehr Steine liegen als vorgesehen, ist es auch nicht möglich das Verhalten in diesem Fall zu testen.
    Für alle anderen Fälle verhält sich die Funktion wie vorgesehen\footnote{siehe Code\ \ref{code:IsTopOfColumnTest}}.

    
\subsection{Integration Tests - Laden und speichern des Spielstands}
    Das Spiel hat eine Speicherlogik. 
    Für diese wird ein String erstellt, welcher den aktuellen Stand des Spieles aufzeichnet.
    Dieser funktioniert wie folgt:\verb!{playerTurn}a{rows}a{columns}a{isFull}aB{boardLayout}!.
    Dieser String wird dann in einem txt-File gespeichert und kann beim neustarten des Spiels aufgerufen werden.
    Für den Test ist es wichtig, dass sich das txt-File ordentlich öffnet und ausliest.
    Zudem muss getestet werden, ob der Speichercode den Spielstand ordnungsgemäß darstellt.
    Auch ist das Verhalten interessant, für den Fall das kein Speicherstand existiert und versucht wird einen zu laden.\\
    Um dem Ziel von Integration Tests zu folgen sind zwischenwerte und interne Abläufe hier unwichtig.
    Von Relevanz is lediglich das richtige Ergebnis, in diesem Fall das richtige Speichern und Auslesen.\\
    Für den Testablauf muss hier nach jedem Durchlauf der Zustand der Dateien wieder zum ausgangszustand zurückgebracht werden.
    Da das Speichern des Spiels eine Datei erstellt, welche zuvor noch nicht da ist.\\
    Das Diagram\ \ref{gph:IntegrationTest} zeigt auf, wie der Speicher- \& Ladeprozess im Spiel funktioniert. 
    Dabei wird alles, was keinen direkten Einfluss auf den Speicher- \& Ladeprozess hat ignoriert.
    \begin{figure}[ht!]
        \centering
        \tikzstyle{block} = [
            rectangle, rounded corners,
            minimum width=3.5cm, minimum height=1.2cm,
            text centered, draw=black,
            text width=3cm
        ]
        \tikzstyle{decision} = [
            diamond, aspect=2,
            text centered, draw=black
        ]
        \tikzstyle{startstop} = [
            ellipse,
            minimum width=4cm, minimum height=1.2cm,
            text centered, draw=black
        ]
        \tikzstyle{arrow} = [
            thick, ->, >=stealth
        ]
    
        \begin{tikzpicture}[node distance=2.5cm]

            \node (start)        [startstop] {Initialisierung eines neuen Boards};
    
            \node (loadLayout)   [block, below of=start] {Laden des Spielfelds};
    
            \node (decisionUser) [decision, below of=loadLayout, yshift=-0.5cm]{Zustandsänderung?};
    
            \node (pressSave)    [block, right of=decisionUser, xshift=3.0cm]{Speicherknopf};
    
            \node (play)         [block, below of=decisionUser]{Aktionen auf dem Spielfeld\\Updaten des Boards};
    
            \node (loadGame)     [block, left of=decisionUser, xshift=-3.0cm]{Ladenknopf};
    
            \node (createSave)   [block, below of=pressSave] {Erstellen der Speicherdatei};
    
            \node (accessSave)   [block, below of=loadGame]{Laden der Speicherdatei\\Updaten des Boards};
    
            % Arrows
            \draw[arrow] (start) -- (loadLayout);
            \draw[arrow] (loadLayout) -- (decisionUser);
    
            \draw[arrow] (decisionUser) -- (pressSave);
            \draw[arrow] (pressSave) -- (createSave);
            \draw[arrow] (createSave) -- (decisionUser);
    
            \draw[arrow] (decisionUser) -- (play);
            \draw[arrow] (play) -- (decisionUser);
    
            \draw[arrow] (decisionUser) -- (loadGame);
            \draw[arrow] (loadGame) -- (accessSave);
            \draw[arrow] (accessSave) -- (decisionUser);
    
        \end{tikzpicture}
    
        \caption{Flowchart für Speicher-/Ladeprozess}\label{gph:IntegrationTest}
    \end{figure}\\
    Aus der Figur\ \ref{gph:IntegrationTest} ist bereits ein Problem des Speicherkonzepts zu erkennen, die Datei wird erst mit erstmaligem Speicher erstellt.
    Der Knopf zum Laden des Spiels hingegen ist bereits mit dem Öffnen des Spiels möglich.
    Dies kann zu Fehlern und undefinierten Verhalten führen.\\
    In der tatsächlichen Durchführung der Tests bewahrheitet sich dies.
    Der \texttt{FileReader} findet keine Datei zum auslesen und wirft ein Error, wenn man den Ladeprozess direkt nach dem Start des Spiels aufruft, ohne zuvor gespeichert zu haben. 

    

\subsection{System Testing}
    Während effektive Unit- und Integration Tests verhältnismäßig effektiv umzusetzen sind. 
    Sind System Tests deutlich komplexer und schwieriger zu implementieren.\\
    Vor allem in sehr großen Projekten ist diese häufig zu komplex\footfullcite[S. 1]{hayes1999}.
    Dieses Projekt ist jedoch verhältnismäßig klein und somit auch in der Hinsicht leichter zu Testen.

\section{statische Tests}
\subsection{Codereview}
    Im Rahmen der statischen Tests wird eine Codeanalyse vorgenommen. 
    Hier wird der Commit \texttt{dec55bf} betrachtet, welcher die Funktion zum Speichern und Laden der Speichern.
    Zu betrachten ist der Code\ \ref{code:setValues1} zum Decoden des Savefile-Inhalts.\\
    Zuerst wird der Code nach seiner Lesbarkeit bewertet. 
    Hier kommt direkt ein Problem auf: Die Benennung der Variablen. 
    Wie in Listing\ \ref{code:setValuesVars} zu erkennen ist sind die Namen nicht leicht zu entschlüsseln, 
    vor allem da sie häufig in Kombination miteinander auftreten und so schwer zu verstehen ist, 
    welche Variable wofür zuständig ist.
    Dieses Problem ist wenig problematisch, wenn nur ein Entwickler an dem Programm arbeitet, 
    jedoch durchaus von größerer Bedeutung, wenn ein Team daran arbeitet.
    Es stellt sich so das Problem heraus, wie der Code in Zukunft zu warten ist. 
    Die Entwicklung kann so verlangsamt werden.
    \begin{figure}[ht!]
        \begin{lstlisting}[caption={Variablen der Funktion}, label={code:setValuesVars}]
            Tile[][] spFeld;
            boolean player1Turn = false;
            boolean full = false;
            int row = -1;
            int column = -1;
            
            char[] scCh = savecode.toCharArray();
            int countA = 0;
            String v = "";
            boolean checkB = false;
            int r=0;
            int c=0;
        \end{lstlisting} 
    \end{figure}\\
    Zudem hat der Code leichte Formatierungsfehler, so sind Teils Leerzeilen ohne Bedeutung platziert.
    Prinzipiell hätte die gesamte Speicherlogik eine eigene Klasse sein sollen, 
    um den Code besser zu modularisieren und langfristig sicher zu stellen, 
    dass weitere Features hinzugefügt werden können. 


\chapter{Probleme des Projektes}
\section{Behobene Probleme}
\section{Nicht behobene Probleme}

\chapter{Fazit}

\begin{appendices}
\chapter{Grafiken}
    \begin{figure}
        \caption{Bild des Spiels}\label{img:gameInProgress}
        \includegraphics[width=\linewidth]{screenshot_game_inprogress.png}
    \end{figure}
    \newpage
    \begin{figure}
        \caption{Projektstruktur vor Verbesserungen (Einstiegspunkt in rot)}\label{gph:startProjectLayout}
        \dirtree{%
        .1 VierGewinnt/.
        .2 lib/.
        .3 junit-platform-console-standalone.jar.
        .2 res/.
        .3 SpielerVsComputer.png.
        .3 SpielerVsSpieler.png.
        .2 src/.
        .3 api/.
        .4 BoardInterface.java.
        .4 BoardTestInterface.java.
        .4 TileInterface.java.
        .3 gui/.
        .4 entity/.
        .5 BordersForCircle.java.
        .5 Circle.java.
        .4 frames/.
        .5 EndFrame.java.
        .5 MainPanel.java.
        .5 OptionsFrame.java.
        .5 StartFrame.java.
        .4 handler/.
        .5 MouseHandler.java.
        .4 main/.
        .5 \textcolor{red}{App.java}.
        .3 logic/.
        .4 Board.java.
        .4 Tile.java.
        .3 test/.
        .4 GameTest.java.
        .2 {.gitignore}.
        .2 README.md.
        .2 TEST.md.
        .2 VierGewinnt.jar.
        .2 win4.jar.
        }
    \end{figure}
    \newpage
\chapter{Tabellen}
    \begin{figure}
        \caption{Planung der Tests für Board.java (nach \fullcite[S. 93f.]{baresi2006introduction})}\label{gph:testQualityPlan}
        \begin{center}
            \begin{tabular}{ | c | c | }
                \hline
                Test Items & Board.java \\
                \hline
                Features to be tested & placeStone, computer algorithm, save/load, winning \\
                \hline
                Features not to be tested & Setters/Getters \\
                \hline
                Approach & \makecell{Unit Tests mit Grenzwerten oder\\
                    Äquivalenzklassen für zu umfangreichen Code\\
                    Integration Tests für einen Spielablauf mit Use Case\\
                    KI-basiertes Testen für höhere Effizienz bei redundanten Fällen}\\
                \hline
                Pass/Fail criteria & \makecell{Alle Funktionen verhalten sich wie erwartet\\
                    Fail bei unter 100\% Success}\\
                \hline 
                Suspension and resumption criteria & 
                    \makecell{Codequalität zu niedrig bzw unlesbar:\\
                    Codeverbesserungen sind umgesetzt\\ \\
                    Kritischer Error/Crash:\\
                    Fix des kritischen Errors}
                    \\
                \hline
                Risks and contingencies & Zeitliche Begrenzungen \\
                \hline
                Deliverables & Bugs und generelle QA \\
                \hline 
                Tasks \& Schedule & Zeit bis Februar 2025 \\
                \hline 
                Staff \& responsibilities & \makecell{Niklas Kaulfers (Umsetzung),\\IIb23 (Bereitstellung des Projekts und Softwareentwicklung)} \\
                \hline 
                Environment needs & JUnit, Java correto 23, IntelliJ IDEA \\
                \hline
            \end{tabular}
        \end{center}
    \end{figure}
    \newpage
\chapter{Code}\label{chp:Code}
\begin{lstlisting}[language=Java, caption={IsTopOfColumnTest.java}, label={code:IsTopOfColumnTest}]
    package test.logic.board;
    
    import api.BoardTestInterface;
    import logic.Board;
    import org.junit.jupiter.api.Assertions;
    import org.junit.jupiter.api.BeforeEach;
    import org.junit.jupiter.api.DisplayName;
    import org.junit.jupiter.api.Test;
    
    public class IsTopOfColumnTest {
    
        BoardTestInterface board;
    
        @BeforeEach
        void setUp() {
            board = new Board();
        }
    
        @Test
        @DisplayName(
            "WHEN column 1 has 3 stones placed THEN return 3"
        )
        void halfwayFullColumnTest() {
            board.placeStone(1);
            board.placeStone(1);
            board.placeStone(1);
    
            Assertions.assertEquals(
                3,
                board.isTopOfColumn(1)
            );
        }
    
        @Test
        @DisplayName(
            "WHEN column 1 has 6 stones THEN return 0"
        )
        void fullColumnTest() {
            for (int i = 0; i < 6; i++) {
                board.placeStone(1);
            }
    
            Assertions.assertEquals(
                0,
                board.isTopOfColumn(1)
            );
        }
    
        @Test
        @DisplayName(
            "WHEN column 1 has 0 stones THEN return 6"
        )
        void emptyColumnTest() {
            Assertions.assertEquals(
                6,
                board.isTopOfColumn(1)
            );
        }
    
        @Test
        @DisplayName(
            "GIVEN a 10x10 board WHEN column 10 has 0 "
          + "stones THEN return 10"
        )
        void emptyColumn10Test() {
            board = new Board(10, 10);
    
            Assertions.assertEquals(
                10,
                board.isTopOfColumn(9)
            );
        }
    
        @Test
        @DisplayName(
            "GIVEN a 10x10 board WHEN column 1 has 10 "
          + "stones THEN return 0"
        )
        void fullColumn10Test() {
            board = new Board(10, 10);
    
            for (int i = 0; i < 10; i++) {
                board.placeStone(1);
            }
    
            Assertions.assertEquals(
                0,
                board.isTopOfColumn(1)
            );
        }
    
        @Test
        @DisplayName(
            "WHEN column -1 is called THEN do nothing"
        )
        void outOfBoundsTooLowTest() {
            Assertions.assertEquals(
                0,
                board.isTopOfColumn(-1)
            );
        }
    
        @Test
        @DisplayName(
            "WHEN column 7 is called THEN do nothing"
        )
        void outOfBoundsTooHighTest() {
            Assertions.assertEquals(
                0,
                board.isTopOfColumn(7)
            );
        }
    
        @Test
        @DisplayName(
            "WHEN column 0 is called and no stones are "
          + "placed THEN return 6"
        )
        void emptyColumn0Test() {
            Assertions.assertEquals(
                6,
                board.isTopOfColumn(0)
            );
        }
    
        @Test
        @DisplayName(
            "WHEN column 6 is called and no stones are "
          + "placed THEN return 6"
        )
        void emptyColumn6Test() {
            Assertions.assertEquals(
                6,
                board.isTopOfColumn(6)
            );
        }
    }
    \end{lstlisting}
    \newpage
    \begin{lstlisting}[language=Java, caption={CodeSnippet:\ Funktion\ setValuesFromSavecode}, label={code:setValues1}]
        private void setValuesFromSavecode(String savecode){
            Tile[][] spFeld;
            boolean player1Turn = false;
            boolean full = false;
            int row = -1;
            int column = -1;
            
            char[] scCh = savecode.toCharArray();//string zu array von chars
            int countA = 0;
            String v = "";
            boolean checkB = false;
            int r=0;
            int c=0;
            
            //iteration ueber jeden einzelnen char von String savecode
            for (char ch : scCh){
                //wenn a
                if (ch == 'a'){
                    
                    switch(countA){
                    case 0:
                        if (v == "1"){
                            player1Turn = true;
                        }
                        else if (v == "2"){
                            player1Turn = false;
                        }
                        break;
                    case 1:
                        row = Integer.parseInt(v);
                        break;
                    case 2:
                        column = Integer.parseInt(v);
                        break;
                    case 3:
                        if (v == "1"){
                            full = true;
                        }
                        else if (v == "0"){
                            full = false;
                        }
                        break;
                    default:
                        System.out.println(
                            "countA in werteVonSavecode ist groesser als 3: " 
                            + countA
                        );
                        break;
                    }
                    
                    countA += 1;
                    v = "";		//zuruecksetzen von v
                }
                //wenn B
                else if (ch == 'B'){
                    break;
                }
                else{
                    v += Character.toString(ch);
                }
            }
        //fuellen des spielfeldVektors
            spFeld = new Tile[row][column];
            for (char ch : scCh){
                
                if (checkB == false){
                    if (ch == 'B'){
                        checkB = true;
    
                    }
                }
                else{
    
                    spFeld[r][c] = new Tile(Character.getNumericValue(ch));
                    
                    if (c < column-1){
                        c += 1;
                    }
                    else{
                        c = 0;
                        r +=1;
                    }
    
                }
                
            }
            
            this.setBoard(spFeld);
            this.setIsFull(full);
            this.setTurn(player1Turn);
        }
    \end{lstlisting}
    
    
\end{appendices}
\printbibliography\end{document}